<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Tech on </title>
    <link>http://blog.github.io/categories/tech/</link>
    <description>Recent content in Tech on </description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 30 Apr 2021 00:00:00 +0000</lastBuildDate><atom:link href="http://blog.github.io/categories/tech/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>How Computer Add Numbers</title>
      <link>http://blog.github.io/2021/04/30/how-computer-add-numbers/</link>
      <pubDate>Fri, 30 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>http://blog.github.io/2021/04/30/how-computer-add-numbers/</guid>
      <description>A hardware simulation of 4-bit numbers adder.
How the addition operates in binary – example: 6 (A)+7 (B) = 13 (C):
 Below is a hardware logic diagram of a full adder, which is used to do 1-bit additions. It uses 5 logic gates, each made out of 4-6 transistors.
 There are also other ways to combine different logic gates to produce a full adder.
To operate 4-bit additions, it requires roughly 4 full adders connecting like below.</description>
    </item>
    
    <item>
      <title>London Oyster Card - ER Model</title>
      <link>http://blog.github.io/2021/04/07/london-oyster-card-er/</link>
      <pubDate>Wed, 07 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>http://blog.github.io/2021/04/07/london-oyster-card-er/</guid>
      <description>Objective
Record information:
Basic user information: name, address Basic Oyster card information: card id, create date, card type, balance Trips: travel from, touch in date and time, travel to, touch out date and time, fare Dummy data
 The technique to produce ER model from the example data is called normalisation. The most popular choice is 3rd Normal Form. It is a 3 steps process, each step depends on the completion of the previous step and progressively transforming the data.</description>
    </item>
    
    <item>
      <title>Sum Of Digits</title>
      <link>http://blog.github.io/2021/03/07/sum-of-digits/</link>
      <pubDate>Sun, 07 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>http://blog.github.io/2021/03/07/sum-of-digits/</guid>
      <description>Sum all the digits of number N (&amp;gt;0), if result has more than one digit, repeat summing all the digits of the result of each round, until reaching a single digit number R.
For example:
$$N = 365 =&amp;gt; 3 + 6 + 5 = 14 =&amp;gt; R = 1 + 4 = 5 $$
Algorithm: $$R = (N – 1) mod 9 + 1$$
Proof
Represent each digit in N as a_{k}</description>
    </item>
    
    <item>
      <title>Unbeatable Noughts &amp; Crosses</title>
      <link>http://blog.github.io/2021/01/12/unbeatable-noughts-crosses/</link>
      <pubDate>Tue, 12 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>http://blog.github.io/2021/01/12/unbeatable-noughts-crosses/</guid>
      <description>The AI algorithm Minimax is used to decide the next best move in two player games like chess and go zero-sum games. It goes through all the possible moves between two players, and scores each simulated game result according to the end status:
 If the AI player wins, it is given a positive score If the opponent player wins, it is given a negative score If it is a draw, it is given score 0  The scores will be rolled up to their upper level nodes:</description>
    </item>
    
    <item>
      <title>Estimate Pi</title>
      <link>http://blog.github.io/2020/12/30/estimate-pi/</link>
      <pubDate>Wed, 30 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>http://blog.github.io/2020/12/30/estimate-pi/</guid>
      <description>Area of square: $$S_s = L*L$$
Area of circle: $$S_c = Pi*(L/2)2$$
 Draw random dots, with sufficient dots, the probability of dots appearing in the circle approaximately equals the area of the circle within the area of the square:
$$N_c ⁄ N_c ≈ S_c ⁄ S_s = (Pi*(L/2)2) ⁄ (L*L)$$
$$=&amp;gt; Pi = N_c ⁄ N_s *4 $$
Play the demo here
Code in Github</description>
    </item>
    
    <item>
      <title>Is 2021 A Prime Number?</title>
      <link>http://blog.github.io/2020/12/23/is-2021-a-prime-number/</link>
      <pubDate>Wed, 23 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>http://blog.github.io/2020/12/23/is-2021-a-prime-number/</guid>
      <description>A prime number is a positive integer that can only be exactly divided by itself and 1.
Algorithm: to judge whether X is a prime number or not, we can assume a number n has n x n = X (n = sqrt(X)). If X is not prime, it will have at least one integer pair n1 and n2, such that n1 x n2 = X, n1∈[2,n], n2∈[n,X]. We can then narrow down the scope that if X is exactly divisible by a number between 2 and sqrt(X), it is not a prime; otherwise, it is a prime.</description>
    </item>
    
    <item>
      <title>Show N^M As Sum Of Consecutive N Odd Numbers</title>
      <link>http://blog.github.io/2020/12/23/sum-of-consecutive-odd-numbers/</link>
      <pubDate>Wed, 23 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>http://blog.github.io/2020/12/23/sum-of-consecutive-odd-numbers/</guid>
      <description>Split n^m into n numbers, the average of the numbers would be n^{m-1}.
If n is odd, we can produce the consecutive odd numbers {…n^{m-1}-4, n^{m-1}-2, n^{m-1}, n^{m-1}+2, n^{m-1}+4…}. For example, for 3^3, it will be {7, 9, 11}.
If n is even, we can produce the consecutive odd numbers {…n^{m-1}-5, n^{m-1}-3, n^{m-1}-1, n^{m-1}+1, n^{m-1}+3, n^{m-1}+5…}. For example, for 4^3, it will be {13, 15, 17, 19}.
It can be written as:</description>
    </item>
    
  </channel>
</rss>
